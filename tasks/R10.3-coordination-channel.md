```yaml
task_id: R10.3
phase: R10
type: Integration
status: complete
created: 2025-11-24
completed: 2025-11-24
witness_verified: true
resolution_policy: timestamp_first
```

# Task R10.3: [Integration] Coordination Channel

## The Constraint

**Before:** Multiple agents can plan conflicting actions â†’ concurrent write errors at execution
**After:** Coordinator detects conflicts from intent channel, resolves, emits decision to coordination channel

---

## The Witness

**Observable Truth:** Conflicting intents detected â†’ coordinator resolves â†’ coordination channel receives single decision

**Why This Witness:**
- Two intents for same file proves conflict exists
- Single decision in coordination channel proves resolution happened
- Conflict resolution policy (priority/timestamp) proves algorithmic coordination
- Serialized execution order proves concurrent planning without concurrent execution

---

## Acceptance Criteria

**Must Verify:**
- [x] CoordinatorNode reads all intents from intent channel
- [x] Conflict detection algorithm identifies overlapping actions (same target)
- [x] Resolution policy implemented (timestamp_first: agent_beta won with earlier timestamp)
- [x] coordination_channel configured with LastValue reducer (latest decision wins)
- [x] Decision includes: approved_agent_id, action, execution_order, deferred list

**Cannot Exist Without:**
- Conflict resolution is **impossible** without coordinator reading all intents
- Single decision is **automatic** with LastValue channel
- Serialized order is **measurable** via execution_order field

---

## Code Pattern

```python
# Minimal code to unlock the witness
from langgraph.graph import StateGraph
from typing import TypedDict

class CoordinationState(TypedDict):
    intents: list[dict]           # From R10.2
    coordination_decision: dict   # LastValue channel

class CoordinatorNode:
    async def coordinate(self, state: CoordinationState) -> dict:
        intents = state.get("intents", [])

        if len(intents) < 2:
            # No conflict, approve first intent
            return {
                "coordination_decision": {
                    "approved_agent_id": intents[0]["agent_id"],
                    "action": intents[0]["action"],
                    "execution_order": [intents[0]["agent_id"]]
                }
            }

        # Detect conflicts
        conflicts = self.detect_conflicts(intents)

        if conflicts:
            # Resolve via policy
            decision = self.resolve_policy(conflicts)
            return {"coordination_decision": decision}

        return {}

    def detect_conflicts(self, intents):
        # Check if multiple intents target same file
        targets = {}
        for intent in intents:
            target = intent["action"]["target"]
            if target in targets:
                return {
                    "conflict_type": "same_target",
                    "intents": [targets[target], intent]
                }
            targets[target] = intent
        return None

    def resolve_policy(self, conflict):
        # Policy: timestamp-first wins
        intents = conflict["intents"]
        winner = min(intents, key=lambda x: x["timestamp"])

        return {
            "approved_agent_id": winner["agent_id"],
            "action": winner["action"],
            "execution_order": [winner["agent_id"]],
            "deferred": [i["agent_id"] for i in intents if i != winner],
            "resolution_policy": "timestamp_first"
        }

# Graph with coordination channel
workflow = StateGraph(CoordinationState)
workflow.add_node("coordinator", CoordinatorNode().coordinate)
```

---

## Execution Protocol

**Prerequisites:**
- R10.2 complete (intent channel functional)
- Conflict detection algorithm designed
- Resolution policy defined

**Execution Steps:**
1. Create CoordinatorNode with coordinate() method
2. Implement detect_conflicts() algorithm
3. Implement resolve_policy() with chosen policy
4. Create StateGraph with LastValue channel for coordination_decision
5. Connect coordinator to intent channel

**Verification Steps:**
1. Trigger two agents to plan actions on same file
2. Verify both intents in intent channel
3. Run coordinator
4. Verify coordination_decision contains single approved agent
5. Verify deferred list contains other agent

---

## The Completion Signal

**Signal:** Conflicting intents resolved, coordination channel contains serialized execution order

**Evidence Required:**
- workflows/coordination_test.py (coordinator resolving conflicts)
- conflict_scenario.json (two intents for same file)
- coordination_decision.json (single approved agent + deferred list)

**State Transition:**
```yaml
before:
  status: roadmap
  witness: impossible (no conflict resolution)

after:
  status: complete
  witness: observed (conflicts resolved, order decided)
  evidence:
    - workflows/coordination_test.py
    - conflict_scenario.json
    - coordination_decision.json
```

---

## Constraint Compliance

**CONTEXT_PRESERVATION:** Coordination decision preserved via LastValue channel
**CONSTRAINT_INHERITANCE:** Coordinator respects resolution policy constraint
**TRACE_REQUIRED:** Decision includes approved_agent_id, deferred list, resolution_policy
**RESOURCE_STEWARDSHIP:** Conflict detection is O(n) scan (minimal)
**RESIDUE_FREE:** No state outside channel

---

## Notes

**Policy Options:**
- timestamp_first: Earliest plan wins
- priority_based: Agent priority levels
- resource_aware: Check current system load
- custom: Domain-specific logic

**Key Insight:** LastValue channel for coordination is correct - only latest decision matters for execution.
