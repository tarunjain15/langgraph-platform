```yaml
task_id: R11.2
phase: R11
type: Feature
status: complete
created: 2025-11-24
completed: 2025-11-24
witness_verified: true
git_worker_lines: 543
void_simulation_verified: true
```

# Task R11.2: [Feature] GitWorker Implementation

## The Constraint

**Before:** Direct git commands in workflows
**After:** GitWorker wraps git operations, exposed via 7-tool interface

## The Witness

**Observable Truth:** `git_worker.void({"action": "push"})` simulates push, shows result, NO actual push

## Acceptance Criteria

- [x] GitWorker implements Worker interface (workers/git_worker.py, 543 lines)
- [x] state() returns branch, uncommitted files, remote status (tested: branch=main, uncommitted=11)
- [x] constraints() returns git rules (e.g., "no force push to main") (2 hard constraints defined)
- [x] execute({"action": "commit"}) performs actual git commit (respects staging requirements)
- [x] void({"action": "push"}) simulates push without executing (tested: would_push_commits shown)

## Code Pattern

```python
class GitWorker:
    async def state(self) -> dict:
        return {
            "branch": self.get_current_branch(),
            "uncommitted": len(self.get_uncommitted_files()),
            "remote_ahead": self.commits_ahead()
        }

    async def void(self, action: dict) -> dict:
        if action["type"] == "push":
            return {"would_push_commits": self.commits_ahead(), "side_effect": False}
        return {}

    async def execute(self, action: dict) -> dict:
        if action["type"] == "commit":
            subprocess.run(["git", "commit", "-m", action["message"]])
            return {"committed": True, "side_effect": True}
```

## Completion Signal

GitWorker.void() simulates git push without actual push, GitWorker.execute() performs commit

## Notes

void() must analyze git state, predict outcome, but NEVER modify repository
