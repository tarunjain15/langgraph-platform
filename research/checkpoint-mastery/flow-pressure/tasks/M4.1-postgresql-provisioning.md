```yaml
task_id: M4.1
phase: M4
type: Integration
status: pending
created: 2025-11-17
```

# Task 4.1: [Integration] PostgreSQL Provisioning

## The Constraint

**Before:** File-based SQLite only accessible from single server → multi-server deployment impossible
**After:** Network-accessible PostgreSQL instance → multi-server deployment enabled

---

## The Witness

**Observable Truth:** `psql` connection to RDS PostgreSQL succeeds from application server, database accessible over network

**Why This Witness:**
- Network-accessible database connection can ONLY exist if PostgreSQL instance was provisioned
- Successful `psql` connection from application server proves network access configured
- This transition is **IRREVERSIBLE** - once network DB exists, it becomes source of truth
- This witness is **measurable** (connection test) and **automatic** (infrastructure exists or doesn't)

---

## Acceptance Criteria

**Must Verify:**
- [ ] AWS RDS PostgreSQL instance created (db.t4g.small or equivalent)
- [ ] Automated backups enabled (7-day retention minimum)
- [ ] Security group configured (allow 5432 from app subnet only)
- [ ] Connection string documented and secured
- [ ] `psql` connection succeeds: `psql postgresql://user:password@host:5432/checkpoints`
- [ ] Database accessible from application servers (not just local machine)

**Cannot Exist Without:**
- Network database connection is **impossible** without provisioned instance
- Cross-server access is **automatic** once network DB configured
- Multi-server capability is **measurable** proof of infrastructure upgrade

---

## Code Pattern

```bash
# AWS RDS provisioning (Terraform example)
resource "aws_db_instance" "checkpoints" {
  identifier        = "checkpoints-db"
  engine            = "postgres"
  engine_version    = "15.4"
  instance_class    = "db.t4g.small"
  allocated_storage = 100  # GB
  storage_type      = "gp3"

  db_name  = "checkpoints"
  username = "checkpoint_user"
  password = var.db_password  # From secrets manager

  # Backups
  backup_retention_period = 7
  backup_window          = "03:00-04:00"  # 3am UTC

  # Networking
  db_subnet_group_name   = aws_db_subnet_group.checkpoints.name
  vpc_security_group_ids = [aws_security_group.checkpoints_db.id]
  publicly_accessible    = false

  # Performance
  max_allocated_storage = 500  # Auto-scaling enabled
  storage_encrypted     = true
  multi_az             = true  # High availability

  tags = {
    Name        = "checkpoints-db"
    Environment = "production"
    Terraform   = "true"
  }
}

# Security group
resource "aws_security_group" "checkpoints_db" {
  name        = "checkpoints-db-sg"
  description = "PostgreSQL access for checkpoint app servers"
  vpc_id      = var.vpc_id

  ingress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = [var.app_subnet_cidr]  # Only app servers
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Connection test
psql "postgresql://${DB_USER}:${DB_PASSWORD}@${DB_HOST}:5432/checkpoints" \
  -c "SELECT version();"
```

---

## Execution Protocol

**Prerequisites:**
- M3.2 complete (Migration decision = "MIGRATE NOW")
- AWS account with RDS permissions
- VPC with private subnets configured
- Secrets manager for database credentials

**Execution Steps:**
1. Generate secure database password: `openssl rand -base64 32`
2. Store password in AWS Secrets Manager
3. Create RDS instance via Terraform/CloudFormation/Console
4. Wait for instance provisioning (~10 minutes)
5. Note endpoint: `checkpoints-db.abc123.us-east-1.rds.amazonaws.com`
6. Test connection from local machine (if allowed)
7. Test connection from application server
8. Document connection string in secure location

**Verification Steps:**
1. Check RDS instance status: `aws rds describe-db-instances --db-instance-identifier checkpoints-db`
2. Verify status = "available"
3. Test connection: `psql postgresql://user:password@host:5432/checkpoints -c "SELECT 1"`
4. Verify security group: only app subnet has access
5. Verify backups enabled: check RDS console
6. Test connection from app server: `ssh app-server "psql $CONNECTION_STRING -c 'SELECT 1'"`

---

## The Completion Signal

**Signal:** PostgreSQL instance running, network connection verified from app servers

**Evidence Required:**
- RDS instance details (endpoint, version, instance class)
- `psql` connection success output
- Security group configuration showing app subnet access
- Backup configuration showing 7-day retention
- Connection test from application server

**State Transition:**
```yaml
before:
  status: pending
  witness: impossible (no network database)
  database: file-based SQLite
  multi_server: blocked

after:
  status: complete
  witness: observed (network database accessible)
  database: network-accessible PostgreSQL
  multi_server: enabled
  evidence: [rds_instance, connection_test, security_config]
```

---

## Constraint Compliance

**CONTEXT_PRESERVATION:** PostgreSQL backups ensure checkpoint data survives infrastructure failures. 7-day retention preserves historical context.

**CONSTRAINT_INHERITANCE:** All application servers inherit database access - shared checkpoint state enables distributed operation.

**TRACE_REQUIRED:** RDS CloudWatch logs trace all connection attempts and queries - full audit trail of database access.

**RESOURCE_STEWARDSHIP:** Right-sized instance (db.t4g.small) with auto-scaling prevents overprovisioning. Minimal necessary infrastructure.

**RESIDUE_FREE:** Automated backups with 7-day expiration prevent unbounded storage growth. Clean retention policy.

---

## Notes

**Critical Insight:** This task is IRREVERSIBLE. Once PostgreSQL is provisioned, it becomes the source of truth. No rolling back to SQLite after data migration.

**Cost Impact:** RDS db.t4g.small ~$35/month + storage costs. SQLite was $0 infrastructure cost. Justify with M3.2 decision metrics.

**Multi-AZ:** Production should enable multi-AZ for high availability. Doubles cost but eliminates single point of failure.

**Connection Pooling:** PostgreSQL has connection limits (100 for t4g.small). M5.1 implements connection pooling.

**Testing Gotcha:** Ensure security group allows app subnet CIDR, not individual IPs (IPs change, subnet doesn't).

**Secrets Management:** NEVER hardcode database password. Use AWS Secrets Manager or environment variables from secure store.
