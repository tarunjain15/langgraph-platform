```yaml
task_id: M4.2
phase: M4
type: Integration
status: pending
created: 2025-11-17
```

# Task 4.2: [Integration] PostgreSQL Schema Creation

## The Constraint

**Before:** PostgreSQL instance empty → no checkpoint storage capability
**After:** PostgresSaver.setup() creates `checkpoints` and `writes` tables → identical schema to SQLite

---

## The Witness

**Observable Truth:** `\dt` in PostgreSQL shows `checkpoints` and `writes` tables with correct schema matching SQLite structure

**Why This Witness:**
- Checkpoint tables existing in PostgreSQL can ONLY happen if PostgresSaver.setup() was executed
- Schema matching SQLite structure proves migration compatibility
- This witness is **measurable** (table existence query) and **automatic** (setup creates schema)

---

## Acceptance Criteria

**Must Verify:**
- [ ] PostgresSaver.setup() executes without errors
- [ ] `checkpoints` table exists with correct columns
- [ ] `writes` table exists with correct columns
- [ ] Indexes created for performance (thread_id, checkpoint_id)
- [ ] Schema matches SQLite structure exactly
- [ ] Foreign key constraints configured correctly

**Cannot Exist Without:**
- Checkpoint tables in PostgreSQL are **impossible** without setup execution
- Schema compatibility is **automatic** once PostgresSaver used
- Index creation is **measurable** proof of production readiness

---

## Code Pattern

```python
from langgraph.checkpoint.postgres import PostgresSaver

# Create PostgreSQL checkpointer
pg_checkpointer = PostgresSaver.from_conn_string(
    "postgresql://user:password@host:5432/checkpoints"
)

# Create schema
pg_checkpointer.setup()

# Verify schema
import asyncpg

async def verify_schema():
    conn = await asyncpg.connect(
        "postgresql://user:password@host:5432/checkpoints"
    )

    # Check tables exist
    tables = await conn.fetch("""
        SELECT tablename FROM pg_tables
        WHERE schemaname = 'public'
    """)
    print(f"Tables: {[t['tablename'] for t in tables]}")

    # Check checkpoints schema
    checkpoints_schema = await conn.fetch("""
        SELECT column_name, data_type
        FROM information_schema.columns
        WHERE table_name = 'checkpoints'
    """)
    print("Checkpoints schema:")
    for col in checkpoints_schema:
        print(f"  {col['column_name']}: {col['data_type']}")

    # Check indexes
    indexes = await conn.fetch("""
        SELECT indexname FROM pg_indexes
        WHERE tablename = 'checkpoints'
    """)
    print(f"Indexes: {[i['indexname'] for i in indexes]}")

    await conn.close()

# Expected output:
# Tables: ['checkpoints', 'writes']
# Checkpoints schema:
#   thread_id: character varying
#   checkpoint_ns: character varying
#   checkpoint_id: character varying
#   parent_checkpoint_id: character varying
#   type: character varying
#   checkpoint: bytea
#   metadata: bytea
# Indexes: [...includes thread_id and checkpoint_id indexes...]
```

---

## Execution Protocol

**Prerequisites:**
- M4.1 complete (PostgreSQL instance running)
- Connection string available
- PostgresSaver installed: `pip install langgraph-checkpoint-postgres`

**Execution Steps:**
1. Install PostgreSQL checkpointer: `pip install langgraph-checkpoint-postgres`
2. Import PostgresSaver: `from langgraph.checkpoint.postgres import PostgresSaver`
3. Create checkpointer with connection string
4. Execute setup: `pg_checkpointer.setup()`
5. Verify tables created: `psql ... -c "\dt"`
6. Verify schema matches SQLite: compare column definitions

**Verification Steps:**
1. Connect to PostgreSQL: `psql postgresql://user:password@host:5432/checkpoints`
2. List tables: `\dt`
3. Describe checkpoints table: `\d checkpoints`
4. Describe writes table: `\d writes`
5. List indexes: `\di`
6. Compare with SQLite schema: `sqlite3 checkpoints.sqlite ".schema"`

---

## The Completion Signal

**Signal:** `checkpoints` and `writes` tables exist in PostgreSQL with correct schema

**Evidence Required:**
- `\dt` output showing both tables
- Schema description showing all columns
- Index listing showing performance indexes
- Schema comparison confirming SQLite compatibility

**State Transition:**
```yaml
before:
  status: pending
  witness: impossible (empty database)
  schema: none

after:
  status: complete
  witness: observed (tables exist with correct schema)
  schema: checkpoints + writes tables created
  evidence: [table_listing, schema_description, index_listing]
```

---

## Constraint Compliance

**CONTEXT_PRESERVATION:** Schema preserves all checkpoint context - thread_id, checkpoint_id, parent_checkpoint_id enable full history reconstruction.

**CONSTRAINT_INHERITANCE:** Schema enforces constraints via foreign keys - writes table references checkpoints table, ensuring data integrity.

**TRACE_REQUIRED:** Every checkpoint traceable via indexed columns - thread_id + checkpoint_id + timestamp enable full audit trail.

**RESOURCE_STEWARDSHIP:** Indexes created for query performance - minimal overhead during writes, maximum speedup during reads.

**RESIDUE_FREE:** Clean schema with no legacy columns - only necessary fields, no technical debt.

---

## Notes

**Schema Compatibility:** PostgreSQL schema must match SQLite exactly for migration to work (M4.3-M4.4).

**Index Strategy:** Indexes on thread_id and checkpoint_id enable fast queries. Trade-off: slower writes, faster reads.

**Setup Idempotency:** PostgresSaver.setup() is idempotent - safe to run multiple times, won't error if tables exist.
