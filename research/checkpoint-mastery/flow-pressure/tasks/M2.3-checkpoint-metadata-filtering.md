```yaml
task_id: M2.3
phase: M2
type: Integration
status: complete
created: 2025-11-17
completed: 2025-11-18
```

# Task 2.3: [Integration] Checkpoint Metadata Filtering

## The Constraint

**Before:** Must iterate all checkpoints to find specific sessions → slow, unscalable
**After:** Query checkpoints by metadata tags (user_id, session_type, step) → instant, indexed

---

## The Witness

**Observable Truth:** Query 100 checkpoints filtered by `session_type="onboarding"` returns correct subset in <5ms

**Why This Witness:**
- Metadata-based filtering that returns only matching checkpoints can ONLY exist if metadata indexing was implemented
- Sub-5ms query time on 100+ checkpoints proves indexed lookup, not iteration
- The ability to filter by multiple metadata fields simultaneously is **impossible** without structured metadata storage
- This witness is **measurable** (query time) and **automatic** (every filtered query proves it)

---

## Acceptance Criteria

**Must Verify:**
- [ ] Store 100 checkpoints with varied metadata tags
- [ ] Filter by single tag (`session_type="onboarding"`) returns correct subset
- [ ] Filter by multiple tags (`session_type="onboarding"`, `step=3`) returns intersection
- [ ] Metadata queries complete in <5ms (measured)
- [ ] No false positives (all returned checkpoints match filter)
- [ ] No false negatives (all matching checkpoints returned)

**Cannot Exist Without:**
- Metadata filtering returning correct subsets is **impossible** without metadata storage
- Sub-5ms query time is **automatic** once indexed metadata exists
- Multi-tag filtering is **measurable** proof of structured metadata support

---

## Code Pattern

```python
from langgraph.checkpoint.sqlite.aio import AsyncSqliteSaver
from typing import TypedDict

class State(TypedDict):
    messages: list
    user_id: str
    session_type: str
    step: int

async def store_with_metadata(checkpointer, config, checkpoint, metadata):
    """Store checkpoint with rich metadata."""
    await checkpointer.aput(
        config,
        checkpoint,
        metadata={
            "user_id": metadata["user_id"],
            "session_type": metadata["session_type"],
            "step": metadata["step"],
            "timestamp": metadata.get("timestamp")
        },
        new_versions={}
    )

async def query_by_metadata(checkpointer, base_config, filter_dict):
    """Query checkpoints by metadata tags."""
    checkpoints = []

    async for checkpoint_tuple in checkpointer.alist(
        base_config,
        filter=filter_dict
    ):
        checkpoints.append(checkpoint_tuple)

    return checkpoints

# Usage example
config = {"configurable": {"thread_id": "user-123"}}

# Store with metadata
await store_with_metadata(
    checkpointer,
    config,
    checkpoint,
    metadata={
        "user_id": "user-123",
        "session_type": "onboarding",
        "step": 3
    }
)

# Filter by single tag
onboarding_checkpoints = await query_by_metadata(
    checkpointer,
    {},
    filter={"session_type": "onboarding"}
)

# Filter by multiple tags (intersection)
specific_checkpoints = await query_by_metadata(
    checkpointer,
    {},
    filter={
        "session_type": "onboarding",
        "step": 3
    }
)
```

---

## Execution Protocol

**Prerequisites:**
- M2.1 complete (AsyncSqliteSaver working)
- Checkpointer with metadata support enabled
- Test dataset with varied metadata tags

**Execution Steps:**
1. Create test dataset: 100 checkpoints with different metadata
   - 30 checkpoints: `session_type="onboarding"`
   - 40 checkpoints: `session_type="support"`
   - 30 checkpoints: `session_type="sales"`
   - Each with `step` values 1-5
2. Test single-tag filtering: `filter={"session_type": "onboarding"}`
3. Verify correct count (30 checkpoints returned)
4. Test multi-tag filtering: `filter={"session_type": "onboarding", "step": 3}`
5. Verify correct count (6 checkpoints returned)
6. Measure query time (should be <5ms)

**Verification Steps:**
1. Store test dataset with varied metadata
2. Query with single filter: `session_type="onboarding"`
3. Count results (should be 30)
4. Query with multi-tag filter: `session_type="onboarding"`, `step=3`
5. Count results (should be 6)
6. Benchmark query time: `time python query_metadata.py`
7. Verify <5ms latency

---

## The Completion Signal

**Signal:** Metadata filtering works with <5ms queries, correct results

**Evidence Required:**
- Test dataset created: 100 checkpoints with metadata
- Single-tag query returns 30 checkpoints (session_type="onboarding")
- Multi-tag query returns 6 checkpoints (session_type="onboarding", step=3)
- Query benchmark showing <5ms latency
- No false positives/negatives verified

**State Transition:**
```yaml
before:
  status: complete
  witness: impossible (no metadata indexing)
  query_method: iterate all checkpoints
  query_time: O(n) - slow

after:
  status: complete
  witness: observed (metadata filtering working)
  query_method: indexed lookup
  query_time: <5ms (constant time)
  evidence: [test_dataset, single_tag_query, multi_tag_query, benchmark]
```

---

## Constraint Compliance

**CONTEXT_PRESERVATION:** Metadata tags enable temporal queries - find all checkpoints for user X in time range Y. Context discoverable across time.

**CONSTRAINT_INHERITANCE:** Child agents inherit parent metadata tags - hierarchical metadata enables nested context queries.

**TRACE_REQUIRED:** Metadata tags make decisions traceable - user_id + session_type + step = full audit trail of what happened when.

**RESOURCE_STEWARDSHIP:** Indexed metadata prevents full table scans - O(1) lookup vs O(n) iteration. Minimal compute waste.

**RESIDUE_FREE:** Metadata is structured - no freeform tags that accumulate cruft. Schema validation ensures clean metadata.

---

## Notes

**Critical Insight:** Metadata filtering removes the constraint of "must load all checkpoints to find specific ones". Indexed metadata → fast queries → scalable checkpoint discovery.

**Metadata Schema:** Keep metadata schema lean - only store queryable fields. Don't use metadata as general key-value store (defeats indexing).

**Common Query Patterns:**
- Find all checkpoints for user X: `filter={"user_id": "user-123"}`
- Find all onboarding sessions: `filter={"session_type": "onboarding"}`
- Find specific step in user's journey: `filter={"user_id": "user-123", "step": 3}`

**Performance Note:** Metadata queries scale with index size, not total checkpoint count. 1M checkpoints with 100 matching metadata = same 5ms query time.

**Testing Gotcha:** Ensure test cleanup removes all test checkpoints. Don't accumulate test metadata that pollutes production queries.
