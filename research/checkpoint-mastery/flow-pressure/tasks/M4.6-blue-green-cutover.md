```yaml
task_id: M4.6
phase: M4
type: Integration
status: pending
created: 2025-11-17
```

# Task 4.6: [Integration] Blue-Green Cutover

## The Constraint

**Before:** All traffic on SQLite → PostgreSQL untested in production
**After:** Traffic switched SQLite → PostgreSQL with zero downtime → 100% on PostgreSQL

---

## The Witness

**Observable Truth:** 100% production traffic on PostgreSQL, zero 5xx errors, SQLite version decommissioned

**Why This Witness:**
- Full production traffic on PostgreSQL can ONLY exist if cutover completed successfully
- Zero errors during cutover proves blue-green strategy worked
- This transition is **IRREVERSIBLE** - PostgreSQL becomes production database
- This witness is **measurable** (traffic percentage, error rate) and **automatic** (load balancer metrics prove it)

---

## Acceptance Criteria

**Must Verify:**
- [ ] PostgreSQL version deployed to green environment
- [ ] 10% traffic routed to green, monitored for 1 hour
- [ ] 50% traffic routed to green, monitored for 1 hour
- [ ] 100% traffic routed to green, monitored for 24 hours
- [ ] Zero 5xx errors during entire cutover
- [ ] PostgreSQL performance metrics healthy (latency, throughput)
- [ ] SQLite version (blue) decommissioned after 24 hour stabilization

**Cannot Exist Without:**
- Zero-downtime cutover is **impossible** without blue-green strategy
- Full traffic migration is **automatic** once load balancer switched
- Production stability is **measurable** via error rates and latency

---

## Code Pattern

```python
# Blue-Green Deployment Configuration

# Step 1: Deploy green environment (PostgreSQL version)
# File: docker-compose.green.yml
version: '3.8'
services:
  app-green:
    image: myapp:postgresql
    environment:
      - DB_TYPE=postgresql
      - DB_CONNECTION_STRING=postgresql://user:password@host:5432/checkpoints
    ports:
      - "8081:8000"  # Green on different port
    labels:
      - "environment=green"
      - "version=postgresql"

# Step 2: Load balancer configuration (nginx example)
upstream backend {
    # Start with 90% blue (SQLite), 10% green (PostgreSQL)
    server app-blue:8000 weight=90;
    server app-green:8081 weight=10;
}

server {
    listen 80;
    location / {
        proxy_pass http://backend;
    }
}

# Step 3: Progressive traffic shift
# 10% → 50% → 100% green

# Monitor metrics at each stage
def monitor_cutover_metrics(duration_minutes=60):
    """Monitor error rate and latency during cutover."""
    import time
    from prometheus_api_client import PrometheusConnect

    prom = PrometheusConnect(url="http://localhost:9090")

    start_time = time.time()
    end_time = start_time + (duration_minutes * 60)

    while time.time() < end_time:
        # Check error rate
        error_rate = prom.custom_query(
            'rate(http_requests_total{status=~"5.."}[5m]) / '
            'rate(http_requests_total[5m])'
        )[0]['value'][1]

        # Check P99 latency
        p99_latency = prom.custom_query(
            'histogram_quantile(0.99, rate(http_request_duration_seconds_bucket[5m]))'
        )[0]['value'][1]

        print(f"Error rate: {float(error_rate):.4f}, P99 latency: {float(p99_latency):.3f}s")

        if float(error_rate) > 0.001:  # >0.1% error rate
            raise ValueError(f"High error rate during cutover: {error_rate}")

        time.sleep(60)  # Check every minute

    print(f"✓ Monitoring complete: {duration_minutes}min with healthy metrics")

# Cutover execution script
async def execute_blue_green_cutover():
    """Execute progressive cutover from SQLite to PostgreSQL."""

    # Stage 1: 10% traffic to green
    print("Stage 1: Routing 10% traffic to PostgreSQL...")
    update_load_balancer_weights(blue=90, green=10)
    monitor_cutover_metrics(duration_minutes=60)

    # Stage 2: 50% traffic to green
    print("Stage 2: Routing 50% traffic to PostgreSQL...")
    update_load_balancer_weights(blue=50, green=50)
    monitor_cutover_metrics(duration_minutes=60)

    # Stage 3: 100% traffic to green
    print("Stage 3: Routing 100% traffic to PostgreSQL...")
    update_load_balancer_weights(blue=0, green=100)
    monitor_cutover_metrics(duration_minutes=24 * 60)  # 24 hours

    # Stage 4: Decommission blue
    print("Stage 4: Decommissioning SQLite version...")
    decommission_blue_environment()

    print("✓ Cutover complete: 100% traffic on PostgreSQL")
```

---

## Execution Protocol

**Prerequisites:**
- M4.5 complete (Data integrity verified)
- Green environment deployed with PostgreSQL
- Load balancer configured for blue-green
- Monitoring dashboard ready
- Rollback plan documented

**Execution Steps:**
1. Deploy green environment (PostgreSQL version)
2. Verify green environment health checks passing
3. Route 10% traffic to green via load balancer
4. Monitor metrics for 1 hour (error rate, latency)
5. If healthy, route 50% traffic to green
6. Monitor metrics for 1 hour
7. If healthy, route 100% traffic to green
8. Monitor metrics for 24 hours
9. If stable, decommission blue environment

**Verification Steps:**
1. Check load balancer weights: `curl http://lb/weights`
2. Monitor error rate: check Grafana dashboard
3. Monitor latency: check P99 metrics
4. Verify PostgreSQL throughput: check checkpoint writes
5. At each stage, verify zero 5xx errors
6. After 24 hours, verify blue environment can be decommissioned

---

## The Completion Signal

**Signal:** 100% traffic on PostgreSQL, zero 5xx errors, blue decommissioned

**Evidence Required:**
- Load balancer configuration showing 100% green
- Monitoring dashboard showing zero errors
- 24-hour metrics showing stable operation
- Blue environment decommissioning confirmation

**State Transition:**
```yaml
before:
  status: pending
  witness: impossible (all traffic on SQLite)
  database: SQLite (blue)
  migration: staged but not live

after:
  status: complete
  witness: observed (100% traffic on PostgreSQL)
  database: PostgreSQL (green) - IRREVERSIBLE
  migration: complete and stable
  evidence: [load_balancer_config, error_metrics, latency_metrics, decommission_log]
```

---

## Constraint Compliance

**CONTEXT_PRESERVATION:** Blue-green strategy preserves continuity - no dropped requests during cutover. Users experience seamless transition.

**CONSTRAINT_INHERITANCE:** PostgreSQL inherits all checkpoint data from SQLite - continuity across infrastructure change.

**TRACE_REQUIRED:** Every cutover stage logged with metrics - full audit trail of migration to production.

**RESOURCE_STEWARDSHIP:** Progressive rollout minimizes risk - only increase traffic if metrics healthy. Efficient risk management.

**RESIDUE_FREE:** Blue environment decommissioned after cutover - no orphaned infrastructure. Clean state.

---

## Notes

**Critical Insight:** This is the IRREVERSIBLE transition. Once 100% traffic on PostgreSQL and blue decommissioned, SQLite is no longer production database.

**Rollback Plan:** If errors occur during 10% or 50% stage, immediately route 100% back to blue (SQLite). Investigate before retrying.

**24-Hour Stabilization:** Required to catch slow-developing issues (memory leaks, connection pool exhaustion, etc.).

**Monitoring is Non-Negotiable:** Never advance to next stage without healthy metrics. Errors = stop and rollback.

**Traffic Percentage:** 10% → 50% → 100% is conservative. Could do 10% → 25% → 50% → 75% → 100% for extra caution.

**Testing Gotcha:** Test blue-green cutover in staging first. Practice rollback procedure before production.
