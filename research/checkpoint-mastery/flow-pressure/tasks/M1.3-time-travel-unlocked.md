```yaml
task_id: M1.3
phase: M1
type: Feature
status: complete
created: 2025-11-17
completed: 2025-11-17
```

# Task 1.3: [Feature] Time Travel Unlocked

## The Constraint

**Before:** Linear time only - cannot revisit or branch from previous states
**After:** Load specific `checkpoint_id` → resume from that exact state → create alternate timeline

---

## The Witness

**Observable Truth:** Time-travel to checkpoint 2, resume with new input → creates checkpoint 6 (branch), original checkpoints 3-5 remain unchanged

**Why This Witness:**
- State branching is **impossible** without checkpoint versioning
- Loading a specific checkpoint_id and creating a new branch can ONLY happen if checkpoints are indexed and queryable
- This is not a feature we built - it **emerged** from M1.1's infrastructure
- The witness is the **branch topology itself** - if c2 → c6 exists alongside c2 → c5, time travel emerged

---

## Acceptance Criteria

**Must Verify:**
- [ ] Create 5 sequential checkpoints: c1 → c2 → c3 → c4 → c5
- [ ] Query checkpoint history, identify c2's checkpoint_id
- [ ] Time-travel to c2 using `checkpoint_id` in config
- [ ] Resume from c2 with new input
- [ ] Verify new checkpoint c6 created (branching from c2)
- [ ] Verify original checkpoints c3, c4, c5 remain unchanged
- [ ] Verify two parallel timelines exist: (c1 → c2 → c3 → c4 → c5) and (c1 → c2 → c6)

**Cannot Exist Without:**
- Checkpoint versioning with parent_id tracking is **impossible** without persistent checkpointing
- Branching timelines are **automatic** once checkpoint_id is queryable
- Time travel is **zero additional code** - emerged from M1.1

---

## Code Pattern

```python
from langgraph.checkpoint.sqlite import SqliteSaver
from langgraph.graph import StateGraph, START, END

# Setup (assumes M1.1 complete)
checkpointer = SqliteSaver.from_conn_string("checkpoints.sqlite")

# Simple stateful graph
class State(TypedDict):
    count: int

def increment(state: State):
    return {"count": state["count"] + 1}

builder = StateGraph(State)
builder.add_node("increment", increment)
builder.add_edge(START, "increment")
builder.add_edge("increment", END)

graph = builder.compile(checkpointer=checkpointer)

# Create linear timeline: c1 → c2 → c3 → c4 → c5
config = {"configurable": {"thread_id": "time-travel-test"}}

for i in range(5):
    result = graph.invoke({"count": i}, config)
    print(f"Checkpoint {i+1}: count = {result['count']}")

# Query checkpoint history
checkpoints = list(checkpointer.list(config))
print(f"\nTotal checkpoints created: {len(checkpoints)}")

# Identify c2 (second checkpoint)
c2 = checkpoints[-4]  # Checkpoints are returned newest-first
print(f"Checkpoint 2 ID: {c2.id}")

# Time travel to c2
time_travel_config = {
    "configurable": {
        "thread_id": "time-travel-test",
        "checkpoint_id": c2.id  # Load c2 specifically
    }
}

# Resume from c2 with new input (creates branch)
print(f"\n--- Time traveling to c2 ---")
state_at_c2 = graph.get_state(time_travel_config)
print(f"State at c2: count = {state_at_c2.values['count']}")

# Continue from c2 with different input → creates c6
result = graph.invoke({"count": 100}, time_travel_config)
print(f"New branch from c2: count = {result['count']}")

# Verify branch created
all_checkpoints = list(checkpointer.list(config))
print(f"\nTotal checkpoints after branch: {len(all_checkpoints)}")
# Expected: 6 checkpoints (c1-c5 original timeline + c6 new branch)

# Verify original timeline unchanged
print("\nCheckpoint topology:")
for i, cp in enumerate(reversed(all_checkpoints)):
    print(f"  c{i+1}: parent = {cp.parent_config['configurable'].get('checkpoint_id', 'START')}")
```

---

## Execution Protocol

**Prerequisites:**
- M1.1 complete (`checkpoints.sqlite` exists with schema)
- LangGraph graph compiled with `checkpointer` parameter
- Understanding of checkpoint versioning (parent_id links)

**Execution Steps:**
1. Create simple stateful graph (counter example above)
2. Generate 5 sequential checkpoints (linear timeline)
3. Query checkpoint history using `checkpointer.list(config)`
4. Identify c2's checkpoint_id (4th from end in reversed list)
5. Create time-travel config with both `thread_id` and `checkpoint_id`
6. Resume from c2 with new input
7. Verify branch created (6th checkpoint exists)
8. Verify original timeline unchanged (c3-c5 still exist)

**Verification Steps:**
1. Run checkpoint count query - should be 5 after linear timeline
2. Run checkpoint count query - should be 6 after branch
3. Inspect checkpoint parent_id links - verify c6 points to c2
4. Verify c5 still points to c4 (original timeline preserved)
5. Use `graph.get_state(time_travel_config)` - should return c2's state exactly

---

## The Completion Signal

**Signal:** Time travel to c2 successful, branch created (c1 → c2 → c6 exists alongside c1 → c2 → c3 → c4 → c5)

**Evidence Required:**
- Terminal output showing 5 checkpoints created (linear timeline)
- Terminal output showing c2's checkpoint_id
- Terminal output showing state at c2 loaded correctly
- Terminal output showing 6th checkpoint created (branch)
- Checkpoint topology diagram showing two parallel timelines
- SQLite query showing parent_id relationships: `SELECT checkpoint_id, parent_id FROM checkpoints WHERE thread_id = 'time-travel-test'`

**State Transition:**
```yaml
before:
  status: complete
  witness: impossible (no checkpoint versioning exists)
  time_travel: blocked
  timeline: linear only

after:
  status: complete
  witness: observed (c2 → c6 branch exists alongside c2 → c5 timeline)
  time_travel: emerged (zero code written for this feature)
  timeline: branching supported
  evidence: [checkpoint topology, parent_id links, branch verification]
```

---

## Constraint Compliance

**CONTEXT_PRESERVATION:** Time travel proves checkpoint continuity - loading c2 exactly reproduces c2's state with zero data loss

**CONSTRAINT_INHERITANCE:** Branched timelines inherit parent constraints - c6 inherits all constraints from c2, not from c5

**TRACE_REQUIRED:** Every checkpoint is fully traced - time travel maintains complete audit trail of all branches

**RESOURCE_STEWARDSHIP:** No additional infrastructure needed - checkpoint versioning emerged from M1.1's schema (zero marginal cost)

**RESIDUE_FREE:** Branching is clean - old checkpoints remain queryable but isolated, no timeline pollution

---

## Notes

**Critical Insight:** We did NOT build Time Travel. We verified it **emerged** from M1.1's checkpoint versioning. The `parent_id` column in the schema enables branching automatically.

**False Emergence Warning:** Do NOT add code for "state versioning" or "history management" or "branch tracking". If you find yourself writing timeline management code, you've violated the emergence principle. Time Travel should work with ZERO additional code beyond M1.1.

**Checkpoint ID is Temporal Index:**
- `thread_id` alone = load latest checkpoint (linear time)
- `thread_id` + `checkpoint_id` = load specific checkpoint (time travel)

**Branch Topology Visualization:**
```
c1 → c2 → c3 → c4 → c5  (original timeline)
       ↓
       c6               (branched timeline from c2)
```

**Use Cases Unlocked:**
- Undo/redo functionality (time travel to any past state)
- A/B testing (branch from checkpoint, try different paths)
- Debugging (replay from specific checkpoint with modified input)
- Human correction (branch from error point, provide corrected input)

**Testing Deeper Branches:** For full verification, create a second branch from c6. This proves arbitrary-depth branching works:
```
c1 → c2 → c3 → c4 → c5
       ↓
       c6 → c7
         ↓
         c8
```
