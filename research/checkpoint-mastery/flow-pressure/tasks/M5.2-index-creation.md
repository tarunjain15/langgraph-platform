```yaml
task_id: M5.2
phase: M5
type: Optimization
status: pending
created: 2025-11-17
```

# Task 5.2: [Optimization] Index Creation

## The Constraint

**Before:** Full table scans for checkpoint queries → 50ms query time
**After:** B-tree indexes on thread_id + checkpoint_id → 2ms query time (25x speedup)

---

## The Witness

**Observable Truth:** `EXPLAIN ANALYZE` shows index scan (not seq scan), query time 50ms → 2ms

---

## Acceptance Criteria

- [ ] Indexes created on thread_id, checkpoint_id, ts (timestamp)
- [ ] Query time <5ms for checkpoint retrieval
- [ ] `EXPLAIN ANALYZE` confirms index usage
- [ ] Write overhead <5% (index maintenance cost)

---

## Code Pattern

```sql
-- Create performance indexes
CREATE INDEX CONCURRENTLY idx_checkpoints_thread_id ON checkpoints(thread_id);
CREATE INDEX CONCURRENTLY idx_checkpoints_checkpoint_id ON checkpoints(checkpoint_id);
CREATE INDEX CONCURRENTLY idx_checkpoints_ts ON checkpoints(ts DESC);
CREATE INDEX CONCURRENTLY idx_writes_checkpoint_id ON writes(checkpoint_id);

-- Verify index usage
EXPLAIN ANALYZE
SELECT * FROM checkpoints
WHERE thread_id = 'user-123'
ORDER BY ts DESC
LIMIT 10;
-- Should show: Index Scan using idx_checkpoints_thread_id
```

---

## The Completion Signal

**Signal:** List checkpoints query: 50ms → 2ms (25x speedup verified)

**Evidence:** EXPLAIN ANALYZE output showing index scans, latency comparison

---

## Notes

**CONCURRENT:** Use `CREATE INDEX CONCURRENTLY` to avoid locking table during index creation.

**Trade-off:** Faster reads, slightly slower writes (<5% overhead). Worth it for read-heavy workload.
